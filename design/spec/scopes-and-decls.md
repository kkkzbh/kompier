# 作用域/声明/名字解析（v0 草案）

本文件回答两个问题：
1) 一个名字在什么范围可见（scope）
2) `a = 3;` 到底是“声明”还是“赋值”

## 作用域（lexical scope）

- 模块作用域：模块顶层声明的符号（函数/常量/类型/子模块名等）
- 函数作用域：参数名、泛型参数名
- 块作用域：`{ ... }` 引入新作用域；块内引入的局部变量只在该块内、且在其引入点之后可见

规则：名字解析从“当前最内层作用域”向外查找，直到模块作用域为止。

## 变量声明形式（建议）

v0 建议提供三类局部绑定：

1) 编译期常量：

```kk
const ten = 10;
```

- `const` 初始化表达式必须是编译期可求值
- `const` 绑定不可变

2) 可变变量：

```kk
mut i = 0;
```

- `mut` 绑定允许多次赋值

3) 默认不可变变量（单次初始化）：

```kk
a = 3; // 首次赋值即声明（见下一节）
```

- 默认绑定不可变（只能被初始化一次）

注：本语言没有 `x: T = ...` 的语法。

如果你需要“给变量一个确定的类型，但暂时不初始化它”，使用未初始化值表达式：

```kk
mut y = int{};   // y 的类型为 int，但值未初始化（读取会报错）
```

## “首次赋值即声明”的语义（关键规则）

把一条语句 `name = expr;` 的语义拆成两步：先解析 `name`，再决定它是“赋值”还是“声明”。

建议规则（更接近 C/C++ 的直觉，也更安全）：

1) 若 `name` 在任意外层作用域已经解析到一个“变量绑定”（局部变量/参数/全局变量），则该语句是对该变量的赋值。
2) 若 `name` 解析到的是“非变量符号”（函数名/类型名/模块名/常量名），则报错：不可赋值。
3) 若 `name` 在所有可见作用域都不存在，则该语句在“当前块作用域”引入一个新的局部变量绑定：
   - 该绑定的类型从 `expr` 推导；推导失败则报错：无法推导
   - 该绑定默认不可变（只允许这一次初始化）

这条规则的含义：
- 你不会因为 `x = ...` 意外创建一个 shadowing 变量来遮蔽外层的 `x`（除非你在新块中写 `x = ...` 且外层不存在该变量；本语言没有 `x: T = ...` 语法）。

（可选替代方案）如果你更喜欢“就近声明、允许隐式 shadowing”，可以改成“只在当前作用域查找”；但它更容易因为拼写错误产生新变量。

## 重新赋值规则（immutability）

- `const`：永远不可赋值
- 默认不可变变量：只允许一次初始化；第二次 `=` 报错
- `mut` 变量：允许多次 `=`

备注：变量绑定语法总是带初始化表达式；“先声明、后初始化”的效果可以用 `T{}` / `Type{}` 这类未初始化值作为占位。
