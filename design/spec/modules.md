# 模块系统（v0 草案）

你在 `design/math.kk` 里已经写了很好的直觉，这里把它整理成可实现规则。

## 模块与文件

- 一个源文件对应一个模块
- `export module xxx;`：声明该文件的模块名为 `xxx`，并且该模块可被导入
- 不写 `export module` 的文件：匿名模块（不可被导入；只用于构建可执行/脚本式入口）。它仍然可以 `import` 其他模块

## import / export import

- `import X;`：把模块 `X` 引入当前作用域，表现为一个**命名空间** `X`。
  - 导入后只能用限定名访问：`X::name`。
  - 子模块也是命名空间：`import X.Y.Z;` 后可写 `X::Y::Z::add`。
- `export import X;`：re-export 依赖。
  - 含义是：任何 `import current;` 的模块都隐式拥有 `import X;` 的可见性（无需再手动导入）。
  - 注意：re-export 不会把 `X` 挂到 `current::...` 之下；`X` 的名字空间仍然是它自己的 `X::...`。

导入别名（v0 建议支持）：
- `import X.Y.Z as Z;`：把模块 `X.Y.Z` 引入当前作用域，但使用别名命名空间 `Z` 访问。
  - 例：`Z::add(...)`
  - 适合避免重复书写 `X::Y::Z::...`

额外引入两条“拍扁到当前作用域”的语句（类 C++）：
- `using X::name;`：把一个名字引入当前作用域，之后可以直接写 `name(...)`。
- `using namespace X;`：把 `X` 的 public 表面全部引入当前作用域。

（可选）为了更贴近 C++：
- `using X::name as local_name;`：带别名的 using。

## 可见性模型（建议实现）

每个模块维护两张符号表：
- `private`：模块自身和其子模块在名字解析阶段可见
- `public`：对外可见（仅包含被 `export` 的符号，以及被 `export import` 的模块表面）

规则：
- `export` 影响 `public` 表
- `import` 只引入对方的 `public` 表

## 名字解析与限定访问

约定：
- 模块名使用 `.` 书写：`export module X.Y;`、`import X.Y;`
- 在代码中访问命名空间使用 `::`：`X::Y::name`

`import X.Y.Z;` 的效果：
- 使得名字解析允许出现限定名 `X::Y::Z::...`（X / X::Y / X::Y::Z 都会作为命名空间链路可解析）
- 不会把任何符号自动注入当前作用域（避免“看起来像变量”的调用、也避免大规模冲突）

名字冲突规则（v0 建议实现）：
- **限定名不冲突**：`X::name` 总是指向 `X` 的导出符号（若存在）。
- **using 的冲突**：
  - `using X::name;` 若把 `name` 引入当前作用域后与现有本地声明/其它 using 引入的同名符号冲突，则编译错误（要求显式改名；v0 不做重载合并）。
  - `using namespace X;` 若引入后产生同名歧义，同样编译错误。
- **本地优先（可选）**：你也可以选择“本地声明遮蔽 using 引入的名字”，但这会隐藏冲突；v0 建议直接报错更利于维护。

（可选后续）支持更多导入形式（例如显式导入列表/过滤），v0 可以先不做。
