# 未初始化值（definite assignment，v0 草案）

规则：读取未初始化的值是编译错误。

## 变量的初始化状态

对每个局部变量维护一个状态：
- `Uninit`：尚未初始化
- `Init`：已初始化

初始状态：
- v0 中所有变量绑定语法都带初始化表达式
- 但初始化表达式可能产生“未初始化值”（例如 `int{}`、`[int; 10]{}`、`(int, double){}`）

因此对一个绑定 `x = expr;`：
- 若 `expr` 保证为已初始化值，则 `x` 进入 `Init`
- 若 `expr` 是未初始化值（或包含未初始化的子值），则 `x` 进入 `Uninit`

补充：
- `T{}` 产生未初始化值 => `Uninit`
- `T{...}` 属于显式构造/转换，若成功则结果视为已初始化值 => `Init`

对聚合：
- `[T; N]{}` / `(T1, ..., Tk){}` => `Uninit`
- `[T; N]{...}` / `(T1, ..., Tk){...}` => 只有当所有元素都初始化成功时，整体为 `Init`（否则编译期报错）

## 读取规则

- 在表达式中读取变量（作为 rvalue）要求该变量在所有可达路径上为 `Init`，否则报错

示例：

```kk
mut x = int{};
use(x); // error: x is uninitialized
```

## 赋值/初始化规则

### 1) 首次赋值即声明

对语句 `a = expr;`，若它引入新变量（见 `design/spec/scopes-and-decls.md`）：

- 为了阻止 `a = a + 1` 这种情况，建议规定：
  - `a` 在该语句的 RHS 分析时视为“已声明但 Uninit”
  - 因而 RHS 读取 `a` 会报“未初始化”错误

### 2) 对既有变量赋值

- 对 `mut` 变量：允许多次赋值
- 对不可变变量：允许 0/1 次赋值（如果你允许“先声明后初始化”）

## 控制流合流（if/else 等）

在 `if` 合流点，变量状态取“交集”：
- 只有当两个分支都为 `Init`，合流后才为 `Init`

示例：

```kk
mut x = int{};
if (cond) { x = 1; }
use(x); // error: not definitely initialized
```

修复方式之一：

```kk
mut x = int{};
if (cond) { x = 1; } else { x = 2; }
use(x); // ok
```

## 聚合的未初始化（数组/元组，占位）

你目前有 `[T; N]{}`、`(T1,T2,...){}` 这类“显式未初始化构造”。

v0 建议先把它们当作“整体 Uninit 值”，禁止读取；以后再扩展到“逐字段/逐元素的 definite assignment”。
