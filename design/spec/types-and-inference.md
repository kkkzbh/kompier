# 类型系统与推导（v0 草案）

总原则：任何没写出来的类型都走推导；推导不了（或推导功能尚未实现）= 编译报错：无法推导。

## v0 类型集合（建议）

内建基础类型（v0）：

有符号整数：
- `char` (1 byte)
- `byte` (1 byte)
- `short` (2 bytes)
- `int` (4 bytes)
- `long` (8 bytes)

无符号整数：
- `uchar` (1 byte)
- `ubyte` (1 byte)
- `ushort` (2 bytes)
- `uint` (4 bytes)
- `ulong` (8 bytes)

浮点：
- `float` (4 bytes)
- `double` (8 bytes)

特殊：
- `void`：只用于声明函数返回值类型；不是可构造的值类型（不能声明 `x = void{}` 之类）

复合类型：
- 定长数组：`[T; N]`
- 元组：`(T1, T2, ... , Tk)`

## tuple 与括号

语法层面：
- `(expr)` 是分组表达式（用于覆盖运算符优先级）
- `(expr,)` 才是一元 tuple 字面量；`(e1, e2, ...)` 是多元 tuple 字面量

类型层面：
- `T` 与 `(T,)` 是不同类型；不做隐式兼容
- 需要兼容时通过显式转换/构造语法完成（见下方 `T{...}`）

## 局部变量类型推导

```kk
pi = 3.14;         // 推导为 double（取决于你的字面量默认规则）
pi2 = float{3.14}; // float
```

推导来源：初始化表达式的类型。

## 显式转换 / 构造：`T{...}`

你决定把“类型的构造/显式转换”统一为 `{}`（对齐 C++ 的 uniform initialization 风格）。

规则（v0）：
- `T{}`：产生一个 `T` 类型的“未初始化值”（读取该值会触发 definite-assignment 错误）
- `T{a, b, ...}`：用列表进行显式构造/转换（是否可用、以及参数个数由 `T` 决定；不支持则报错）

注：
- `T(expr)` 仅表示普通函数调用；不再承担“类型转换/构造”的语义。
- tuple/array 这类类型也使用同样的 `{}` 风格：`(int, double){...}`、`[int; 10]{...}`。

### tuple 构造（v0）

对 tuple 类型 `(T1, T2, ..., Tk)`：
- `(T1, T2, ..., Tk){}`：产生未初始化 tuple
- `(T1, T2, ..., Tk){ e1, e2, ..., ek }`：逐元素初始化；数量必须严格等于 `k`

### array 构造（v0）

对 array 类型 `[T; N]`（`N` 为 const 可求值）：
- `[T; N]{}`：产生未初始化数组
- `[T; N]{ e }`：填充初始化（所有元素都用 `T{e}` 初始化）
- `[T; N]{ e1, e2, ..., eN }`：逐元素初始化

其它元素个数一律报错（避免出现“只初始化一部分、剩下元素未初始化”的隐式行为）。

推导失败例子（语法层面不会出现“没有初始化的变量绑定”）：

当你需要一个“已知类型但未初始化”的值时，用 `T{}` / `Type{}`：

```kk
mut x = int{};   // x 的类型为 int，但值未初始化（读取会报错）
```

## 函数返回类型推导

当函数未写 `-> Type` 时：

1) 若函数体内存在 `return expr;`：
   - 收集所有 `return expr` 的表达式类型
   - v0：必须完全相同；不相同则报错（不做 common 提升）
2) 若函数体内没有 `return expr;`（只有 `return;` 或完全没有 return）：推导为 `void`
3) 若同时出现 `return;` 与 `return expr;`：报错（返回类型不一致）

## 参数类型省略：abbreviated function template

你在示例里允许：

```kk
export add(a: int, b) -> int { ... }
export mul(x, y) { return x * y; }
```

在“静态类型 + 单态化（C++/Rust 风格）”的实现里，函数定义处无法从调用点反推参数类型，除非把它视为泛型。

因此 v0 规则：

- 若某个参数未写类型标注，则它引入一个新的泛型类型参数，并在调用点由实参类型推导（abbreviated function template）

直觉上等价于 C++20 的 abbreviated function template：

```cpp
auto mul(auto x, auto y) { return x * y; }
```

这样做的后果是：
- `mul` 的函数体通常需要等到实例化后才能完整类型检查（接近 C++ templates 的行为）

## 字面量与 common 提升（占位）

数组/元组字面量通常需要计算元素的 common 类型。

建议规则（v0 草案）：

- 不允许窄化（narrowing）
- common 提升仅用于字面量/聚合字面量的“元素统一”（例如 `[1,2,3]` 推导数组元素类型），不改变其它场景的隐式转换策略

数值类隐式提升（用于 common 计算）建议按“逐元素检查是否窄化”来定义：

- 同类整数之间：允许向更宽的整数类型提升
- 有符号 -> 无符号：允许，但必须对每个被提升的元素表达式满足“非窄化”
  - 若元素是 const 可求值整数：要求值 `>= 0` 且能被目标无符号类型表示
  - 若元素不是 const：v0 直接禁止（否则你无法在编译期验证不会把负数变成大无符号数）
- 整数 -> 浮点：允许，但必须对每个被提升的元素表达式满足“非窄化”
  - 若元素是 const 可求值整数：要求该值能被目标浮点类型精确表示
  - 若元素不是 const：v0 直接禁止

注：按这套规则，`long -> float` 基本总会被判为窄化（除非值非常小且可精确表示），因此会被拒绝，这与你的目标一致。

### 什么是 tuple/array 结构一致性

当你需要对“复合字面量的元素”做 common 推导时（例如数组字面量 `[(1,2), (3,4)]`），如果元素本身也是 tuple/array，那么 common 不是简单的“选一个更大的类型”，而是需要它们的结构对齐：

- tuple：所有元素必须有相同的 arity（元素个数）
  - 例如：`(1, 2)` 与 `(3, 4)` 结构一致，可以逐位置计算 common：`(common(int,int), common(int,int))`
  - 例如：`(1, 2)` 与 `(3, 4, 5)` 结构不一致，报错

- array：所有元素必须有相同的长度 `N`（以及同为 array）
  - 例如：`[int; 2]{1,2}` 与 `[int; 2]{3,4}` 结构一致
  - 例如：`[int; 2]{1,2}` 与 `[int; 3]{3,4,5}` 结构不一致，报错

结构一致后，再对齐到对应位置/元素递归计算 common。
