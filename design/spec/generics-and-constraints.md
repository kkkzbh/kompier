# 泛型与约束（v0 草案）

本文件解释：
- 约束在“调用点检查”与“实例化时检查”的区别
- v0 的约束模型（约束只写在泛型参数列表里）

## 泛型的编译策略（建议 v0：单态化 / monomorphization）

v0 推荐走 C++/Rust 风格：
- 泛型函数本体以 AST/IR 模板形式保存
- 当出现具体调用时，用具体类型参数生成一个专门版本并编译

v0 范围：
- 不提供：显式实例化、预编译
- 可能提供：跨模块缓存（同一个专门版本在不同模块/编译单元复用）

## 约束检查：调用点 vs 实例化点

先区分两个“位置”：

- 调用点（call site）：源代码里写 `del(a, b)` 的地方
- 实例化点（instantiation site）：编译器真正生成 `del<T=..., U=...>` 专门版本的地方

在“单态化”实现里，实例化通常由调用触发，所以两者经常重合；但当你做跨模块缓存时，实例化产物可能来自缓存（不一定在当前模块现场生成），两者就会分离。

差异主要体现在：
- 错误报告位置：
  - 调用点检查：错误更贴近用户写的调用，诊断更友好
  - 实例化点检查：如果实例化发生在别处，错误可能离调用更远
- 什么时候能发现错误：
  - 调用点检查更早（在决定类型参数后立刻）
  - 实例化点检查可能更晚（等到真的生成专门版本时）

v0 建议：
- 约束在“实例化之前”检查，但把诊断归因到“触发实例化的调用点”（如果是调用触发）。

## 显式实例化（v0 不做）有什么用

你目前的决定是“不提供显式实例化”，这对 v0 完全没问题。显式实例化主要在以下场景变得有价值（即使你不做预编译）：

- 跨模块缓存/复用：把某个 `f<int>` 的生成放在一个固定地方产出并缓存，其它模块只复用它，避免重复 codegen
- 库发布/编译边界：库作者显式声明“这个库保证提供 `f<int>`/`f<double>`”，下游无需在自己模块实例化
- 编译时间可控：把重模板的实例化集中到少数文件，减少无意间的全局实例化开销
- 测试/诊断：显式触发某组类型参数的实例化，提前暴露约束/替换失败，而不必写一堆调用点

如果你短期内不做“库发布 + 跨模块缓存/复用”，那不提供显式实例化是很合理的简化；建议只在文档里保留这个概念。

## 约束模型（v0）：命名约束 + 显式实现（trait）

含义：约束是一个“命名的类型集合”（trait），由 `impl` 显式把某个类型加入集合；在泛型参数列表中用 `T: TraitName` 引用。

例：

```kk
sealed trait Integer;

export del<T, U: Integer>(x: T, y: U) {
  return x / y;
}
```

特点（v0）：
- **约束只出现在泛型参数列表**：`<T, U: Integer>`；不提供 `requires { ... }` 或 where-clause。
- **trait 是名义(nominal)的**：满足与否取决于是否存在 `impl Trait for Type;`。
- **trait 先做 marker**：v0 不包含方法/关联类型语法（因此它不是“能力契约”，只是“集合名”）。

为避免你担心的 “用户把不该算 Integer 的类型塞进来”，v0 加一条规则：
- `sealed trait`：被标记为 `sealed` 的 trait **只能由编译器/标准库提供 impl**；用户代码不得为其添加 impl。
  - v0 建议：像 `Integer` 这类“基础数值分类”都做成 `sealed`。
  - 非 sealed trait 仍允许用户扩展，但由于 v0 还没有 trait 方法契约，这类 trait 的语义仅用于“类型集合筛选”。

v0 语法与限制（建议实现）：
- 声明：`export? sealed? trait Name;`
- 实现：`impl Name for Type;`
- 约束：只支持单个约束 `T: Name`（见 `design/spec/grammar.md`）
- 一致性：同一程序里，同一个 `(Trait, Type)` 至多允许一个 impl；重复则编译错误。
- impl 形式：v0 只允许为具体类型写 impl（不支持 `impl<T> Trait for ...`），避免重叠/选择问题。
- sealed：对 `sealed trait`，禁止用户提供 impl（诊断指向 impl 位置）。

注：marker trait 阶段只解决“能否作为某类参数/泛型实例化”的筛选；当你以后引入 trait 方法/运算符 trait 时，它才会变成真正的“能力契约”。

## 语法速览（面向 C++ 使用者）

把 trait 当作“概念名字”，把 impl 当作“把某个类型加入这个集合”的声明。

```kk
// 1) 定义一个 trait（v0: marker）
export sealed trait Integer;

// 2) 编译器/标准库为内建类型提供 impl（用户代码禁止为 sealed trait 添加 impl）
// impl Integer for int;
// impl Integer for long;

// 3) 在泛型参数上写约束
export del<T, U: Integer>(x: T, y: U)
{
    return x / y;
}
```

对应的 C++ 类比（只是帮助理解，不是逐字等价）：

```cpp
template<class T>
concept Integer = /* ... */;

template<class T, Integer U>
auto del(T x, U y) { return x / y; }
```

差异点（v0）：
- C++ concept 通常是一个可计算的布尔条件；这里的 trait 是名义集合，由 `impl` 显式加入。
- v0 的 trait 不包含方法签名，因此它不表达“必须支持哪些操作”；要表达操作契约需等后续引入 trait 方法或把运算符建模成 trait。

## 不采用“裸 structural requires”模型（但允许未来扩展）

本项目 v0 不做 `requires { ... }` 这类 structural 约束表达式。像 `Integer` 这类分类通过 `sealed trait` + 编译器/标准库提供 impl 来表达。

## 项目决定（当前）

- 约束模型：采用命名 trait + 显式 impl；约束只写在泛型参数列表中
- 基础数值分类使用 `sealed trait`，避免用户错误扩展
- 检查时机：调用点体验优先（错误尽量归因到触发实例化的调用点）；实现上可在实例化前验证
- 不提供：显式实例化、预编译
- 可能提供：跨模块缓存（使“调用点”和“实例化点”在工程上分离）
